# Introduction to Data Analytics

## Loading and Inspecting Data Sets
<hr>

The following line of code reads a data set that contains weekly prices, promotional activity, and sales for 20 different brands of beer. The data come from a Chicago grocery retailer (Dominick's Finer Foods) and cover more than five years of transactions. The data set is publically available from the Kilts Center for Marketing at the University of Chicago and can be accessed here https://www.chicagobooth.edu/research/kilts/datasets/dominicks.

```{r}
beer = read.csv("beer.csv", sep=",")
```

Notice we used the `sep=` option to specify the delimiter used in our data file (which is a comma `,` for this data file).

We always want to view the data after importing to make sure all the values were read-in correctly. To inspect the first few lines of a data set, use the `head( )` command.

```{r results="hide"}
head(beer)
```

```{r echo=FALSE}
head(beer) %>% 
  kable() %>%
  kable_styling(font_size=10) %>%
  scroll_box(width = "100%")
```

We can see that our data set contains 11 different variables (i.e., columns). A brief summary of each variable is provided below. 

- `store`: unique store ID number 
- `upc`: Universal Product Code
- `week`: week ID number
- `move`: number of units sold
- `price`: retail price in US dollars
- `sale`: indicator of promotional activity
- `profit`: gross profit margin
- `brand`: brand name
- `packsize`: number of items in one package
- `itemsize`: size of items in one package
- `units`: units of items

Finally, we need to attach the data set so that R knows where to find the variables we want to analyze (e.g., move, price).


```{r}
attach(beer)
```

Now we can access/view any of the variables by typing their name. For example, let's look at the first 5 observations of the `price` variable.

```{r}
price[1:5]
```

Here the closed brackets `[ ]` allow us to subset the data and the numbers `1:5` tell R to return observations 1, 2, 3, 4, and 5.

<br>

## Statistical Summaries
<hr>

We can perform a variety of statistical summaries on our data using R's built-in functions. A summary of commonly used statistical functions is provided below.

```{r echo=FALSE}
names = c("mean","median","variance","standard deviation","correlation")
functions = c("`mean( )`","`median( )`","`var( )`","`sd( )`","`cor( )`")
dt = data.frame(names,functions)
names(dt) = c("Statistic","R Function")
dt %>%
  kable() %>%
  kable_styling(full_width = FALSE)
```

For example, we can compute the average demand (i.e., units sold) variable using the `mean( )` function.


```{r}
mean(move)
```


Now suppose we wanted to find the average demand only for a certain brand of beer, say Budweiser. To do this, we first need to subset `move` and only include observations where `brand` is equal to `BUDWEISER BEER`.


```{r results="hide"}
move[brand=="BUDWEISER BEER"]
```

Again, using closed brackets `[ ]` allow us to subset the data. We are interested in the `move` variable, but now we only want the observations where the condition stated inside the brackets is satisfied. Note: a double equals sign `==` is always used when writing logical statements to check equality.

Now we can use the `mean( )` function to compute the desired average demand for Budweiser.


```{r}
mean(move[brand=="BUDWEISER BEER"])
```

An all-purpose way to compute averages across different factor levels is to use the `aggregate( )` function. The first argument specifies the variable we want to average and associated categorical/factor variable, and the second argument specifies the function we want to execute (i.e., the mean).


```{r results="hide"}
aggregate(move ~ brand, FUN=mean)
```

```{r echo=FALSE}
aggregate(move ~ brand, FUN=mean) %>%
  kable() %>%
  kable_styling(full_width=F)
```

<br>

## Graphical Summaries
<hr>

Creating visual data summaries in R is also one of its strengths. Examples of useful graphical functions include `hist( )`, `boxplot( )`, `plot( )`, `pie( )`, `barplot( )`.

An example of a **histogram** of weekly demand is shown below.

```{r}
hist(move, main="Distribution of Beer Sales Volume")
```

Here the `main=` option allows us to customize the plot title. We can also use the `breaks=` option to control the bin width.

```{r}
hist(move, main="Distribution of Beer Sales Volume", breaks=50)
```


We can also use a **boxplot** to look at the distribution of balance. To do this, we'll use the `boxplot( )` function.


```{r}
boxplot(move, main="Distribution of Beer Sales Volume")
```


Notice how the extreme positive values (outliers) make the boxplot hard to analyze. We can remove these outliers with the `outline=FALSE` option.


```{r}
boxplot(move, main="Distribution of Beer Sales Volume", outline=FALSE)
```

We can also use the `boxplot( )` function to see how the distribution of demand changes across brands of beer.


```{r}
boxplot(move ~ brand, main="Distribution of Beer Sales Volume", outline=FALSE, xlab="", ylab="weekly units sold")
```


The first argument tells R that we want to plot move against brand. Note that the numeric variable (e.g., move) must always come before the factor variable (e.g., brand). Weâ€™ve also added labels to the x- and y-axes using the `xlab=` and `ylab=` options.

One issue with the plot above is that the labels on the x-axis are too wide. To solve this problem, we can rotate the x-axis labels by adding `las=2` as an option in the `boxplot( )` command. We will also want to slightly adjust the plot margins to allow for more space below the graph. This can be done by adding `par(mar=c(a,b,c,d))` before the `boxplot( )` command, where `a,b,c,d` denote the bottom, left, top and right margins, respectively. Lastly, we can use the `cex.axis` option to adjust the axis label sizes.

```{r}
par(mar=c(10.1,4.1,4.1,2.1))
boxplot(move ~ brand, main="Distribution of Beer Sales Volume", outline=FALSE, xlab="", ylab="weekly units sold", las=2, cex.axis=.75)
```

We can create **scatter plots** using the `plot( )` function.

```{r}
plot(price, move, main="Beer Demand Patterns")
```

The first argument corresponds to the variable on the x-axis, while the second corresponds to the variable on the y-axis.

To modify the type or color of the points in the above plot, we can add `pch` and `col` options. For example, let's change the points to be closed circles (`pch=16`) that are red (`col=2`).

```{r}
plot(price, move, main="Beer Demand Patterns", pch=16, col=2)
```

Often times, adding color is a great way to incorporate information about other variables. For example, should the relationship between price and demand change by brand? The answer is likely yes. To see this visually, let's change the color of each point to represent the corresponding brand.


```{r}
palette = rainbow(20)
colors = palette[as.numeric(as.factor(brand))]
plot(price, move, main="Beer Demand Patterns", pch=16, col=colors)
legend("topright", legend=sort(unique(brand)), pch=16, col=colors, cex=.5, bty="n")
```

The first line of code generates 20 unique colors from a rainbow palette, one for each brand. Because there are hundreds of points on our scatter plot, we need to identify assign a color to each point. This is what the second line of code does. In the third line, we simply use the `colors` object we just created to specify point colors.

The last line of code adds a legend to the plot so that we know what the colors correspond to. The first argument indicates the legend position, the second argument `legend` indicates the values to be shown on the legend, the third argument `pch` is the point type, the fourth argument `col` is the color for each value, and the fifth argument `cex` adjusts the text size.

```{r echo=FALSE}
detach(beer)
```